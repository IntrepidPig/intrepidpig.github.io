<!DOCTYPE html>
<html>

<head>
	<title>Blog: MEXPRP</title>
	<link href="/index.css" rel="stylesheet">
	<link href="https://fonts.googleapis.com/css?family=PT+Serif|Source+Sans+Pro:600" rel="stylesheet">
</head>

<body>
	<div id="nav">
		<div class="nav-link">
			<a href="/">Home</a>
		</div>
		<div class="nav-link">
			<a href="/blog">Blog</a>
		</div>
		<div class="nav-link">
			<a href="/projects">Projects</a>
		</div>
		<div class="nav-link">
			<a href="/contact">Contact</a>
		</div>
		<div class="nav-link">
			<a href="/about">About</a>
		</div>
		<div class="nav-link owner">
			<a class="owner-link" href="/about">by IntrepidPig</a>
		</div>
	</div>
	<div class="content">
		<h1 id="mexprp">MEXPRP</h1>
<p>MEXPRP is a project I have been working on for a while now. It's a math expression parser written completely in Rust. There's not much special about it, but one thing about it that is somewhat unique (for better or for worse) is that it is written almost completely from scratch. It has only two dependencies, <code>log</code> and <code>failure</code>. The only standard library features it uses outside of the prelude are some <code>fmt</code> traits, <code>sync::Once</code>, <code>cmp::PartialOrd</code>, and <code>HashMap</code>. It parses equations with a completely standalone parsing implementation. Whether or not this was a good idea, I'm not sure. The only reason I did it that way was because I couldn't figure out how any parser-combinator libraries for Rust worked. In the end, it was quite a journey that I think was well worth it.</p>
<p>The main reason I wrote MEXPRP was for a 3D equation grapher I've been working on. Now that's not near done, so it's being saved for a future post. Of course, I could've used an existing Rust expression parser, but the only other one was a <code>0.1.0</code> library that had what I considered I somewhat strange API. Also, for some reason I've been kind of interested in keeping the dependencies down for the 3D equation grapher I was talking about. Anyway, now there's <a href="https://xkcd.com/927/">at least two</a> <code>0.x</code> Rust math expression libraries with API's that can be considered strange.</p>
<h2 id="usage">Usage</h2>
<p>The simplest, but not always the most efficient, way to use MEXPRP is with <code>mexprp::eval()</code>. This function takes a <code>&amp;str</code> as an argument, parses it, and evaluates it. E.g. like this:</p>
<pre style="background-color:#272822">
<span style="background-color:#272822;color:#f8f8f2;">mexprp::eval(</span><span style="background-color:#272822;color:#e6db74;">&quot;(2 + 7) / 3&quot;</span><span style="background-color:#272822;color:#f8f8f2;">)</span><span style="background-color:#272822;color:#f92672;">? </span><span style="background-color:#272822;color:#75715e;">// 3.0
</span></pre>
<p>MEXPRP also supports some functions and constants.</p>
<pre style="background-color:#272822">
<span style="background-color:#272822;color:#f8f8f2;">mexprp::eval(</span><span style="background-color:#272822;color:#e6db74;">&quot;sin(max(2, 3, pi))&quot;</span><span style="background-color:#272822;color:#f8f8f2;">)</span><span style="background-color:#272822;color:#f92672;">? </span><span style="background-color:#272822;color:#75715e;">// ~0.0
</span></pre>
<p>A &quot;better&quot; way to evaluate an expression is to compile it first, with the <code>Expression</code> struct. This has the advantage of retaining a completely parsed and organized instance of an expression for faster evaluation.</p>
<pre style="background-color:#272822">
<span style="background-color:#272822;font-style:italic;color:#66d9ef;">let</span><span style="background-color:#272822;color:#f8f8f2;"> expr </span><span style="background-color:#272822;color:#f92672;">= </span><span style="background-color:#272822;color:#f8f8f2;">Expression::parse(</span><span style="background-color:#272822;color:#e6db74;">&quot;3 ^ (4 - 1)&quot;</span><span style="background-color:#272822;color:#f8f8f2;">)</span><span style="background-color:#272822;color:#f92672;">?</span><span style="background-color:#272822;color:#f8f8f2;">;
</span><span style="background-color:#272822;color:#f8f8f2;">expr.</span><span style="background-color:#272822;color:#66d9ef;">eval</span><span style="background-color:#272822;color:#f8f8f2;">()</span><span style="background-color:#272822;color:#f92672;">? </span><span style="background-color:#272822;color:#75715e;">// 27.0
</span></pre>
<p>But what's the point of being able to evaluate the same expression over and over again? Well, you can evaluate expressions with variables set to a specific value by evaluating it with a context.</p>
<pre style="background-color:#272822">
<span style="background-color:#272822;font-style:italic;color:#66d9ef;">let</span><span style="background-color:#272822;color:#f8f8f2;"> expr </span><span style="background-color:#272822;color:#f92672;">= </span><span style="background-color:#272822;color:#f8f8f2;">Expression::parse(</span><span style="background-color:#272822;color:#e6db74;">&quot;3x / 6&quot;</span><span style="background-color:#272822;color:#f8f8f2;">)</span><span style="background-color:#272822;color:#f92672;">?</span><span style="background-color:#272822;color:#f8f8f2;">;
</span><span style="background-color:#272822;font-style:italic;color:#66d9ef;">let </span><span style="background-color:#272822;color:#f92672;">mut</span><span style="background-color:#272822;color:#f8f8f2;"> ctx </span><span style="background-color:#272822;color:#f92672;">= </span><span style="background-color:#272822;color:#f8f8f2;">Context::new();
</span><span style="background-color:#272822;color:#f8f8f2;">ctx.</span><span style="background-color:#272822;color:#66d9ef;">set_var</span><span style="background-color:#272822;color:#f8f8f2;">(</span><span style="background-color:#272822;color:#e6db74;">&quot;x&quot;</span><span style="background-color:#272822;color:#f8f8f2;">, </span><span style="background-color:#272822;color:#ae81ff;">8.0</span><span style="background-color:#272822;color:#f8f8f2;">);
</span><span style="background-color:#272822;color:#f8f8f2;">expr.</span><span style="background-color:#272822;color:#66d9ef;">eval_ctx</span><span style="background-color:#272822;color:#f8f8f2;">(</span><span style="background-color:#272822;color:#f92672;">&amp;</span><span style="background-color:#272822;color:#f8f8f2;">ctx)</span><span style="background-color:#272822;color:#f92672;">?</span><span style="background-color:#272822;color:#f8f8f2;">; </span><span style="background-color:#272822;color:#75715e;">// 4.0
</span><span style="background-color:#272822;color:#f8f8f2;">ctx.</span><span style="background-color:#272822;color:#66d9ef;">set_var</span><span style="background-color:#272822;color:#f8f8f2;">(</span><span style="background-color:#272822;color:#e6db74;">&quot;x&quot;</span><span style="background-color:#272822;color:#f8f8f2;">, </span><span style="background-color:#272822;color:#ae81ff;">10.0</span><span style="background-color:#272822;color:#f8f8f2;">);
</span><span style="background-color:#272822;color:#f8f8f2;">expr.</span><span style="background-color:#272822;color:#66d9ef;">eval_ctx</span><span style="background-color:#272822;color:#f8f8f2;">(</span><span style="background-color:#272822;color:#f92672;">&amp;</span><span style="background-color:#272822;color:#f8f8f2;">ctx)</span><span style="background-color:#272822;color:#f92672;">?</span><span style="background-color:#272822;color:#f8f8f2;">; </span><span style="background-color:#272822;color:#75715e;">// 5.0
</span></pre>
<p>A context is implemented with two hashmaps with <code>String</code>s as keys. One of them holds variable definitions, represented as <code>Terms</code>. The other holds function definitions, represented as <code>Func</code> trait objects. Both of these hashmaps are public fields so they can be manipulated however you wish. The <code>set_var</code> and <code>set_func</code> functions are mostly just sugar.</p>
<p>When defining custom functions, you should be aware of a minor drawback. Expressions need to be parsed with the custom context containing the custom function definitions in order for them to recognized as functions instead of variables during parsing. The reason for this is that without a list of functions present at parse time, the parser has no way to know if a name in the expression is a variable or a function. For example, in <code>foo(3 + 5)</code>, <code>foo</code> could be a function called with one argument, or a variable multiplied by <code>(3 + 5)</code>.</p>
<p>In order to bypass this, simply create a context before parsing the expression, then use <code>Expression::parse_ctx()</code> to parse the expression. The expression still has to be evaluated with a context as well. This context can differ from the one it was parsed with, but it should still contain any definitions necessary for the expression to be evaluated or attempts to evaluate it will fail.</p>
<p>There are two ways to define a function. A function is anything that implements the <code>func::Func</code> trait. There is a blanket <code>impl</code> of this trait for all <code>Fn(&amp;[Term], &amp;Context) -&gt; Calculation</code>, allowing you to pass in a closure. You can also pass in an empty struct that you implement <code>Func</code> for manually, which is no harder then writing it as a closure. The func trait consists of one method, with the signature <code>fn(args: &amp;[Term], ctx: &amp;Context) -&gt; Calculation</code>. (A <code>Term</code> is just an <code>Expression</code> without the metadata.) In case the arguments given were not properly formatted (e.g. there was an incorrect amount given), you can just return <code>Err(MathError::IncorrectArguments)</code>.</p>
<pre style="background-color:#272822">
<span style="background-color:#272822;font-style:italic;color:#66d9ef;">let </span><span style="background-color:#272822;color:#f92672;">mut</span><span style="background-color:#272822;color:#f8f8f2;"> ctx </span><span style="background-color:#272822;color:#f92672;">= </span><span style="background-color:#272822;color:#f8f8f2;">Context::new();
</span><span style="background-color:#272822;color:#f8f8f2;">ctx.</span><span style="background-color:#272822;color:#66d9ef;">set_func</span><span style="background-color:#272822;color:#f8f8f2;">(</span><span style="background-color:#272822;color:#e6db74;">&quot;funca&quot;</span><span style="background-color:#272822;color:#f8f8f2;">, |</span><span style="background-color:#272822;font-style:italic;color:#fd971f;">args</span><span style="background-color:#272822;color:#f8f8f2;">: </span><span style="background-color:#272822;color:#f92672;">&amp;</span><span style="background-color:#272822;color:#f8f8f2;">[Term], </span><span style="background-color:#272822;font-style:italic;color:#fd971f;">ctx</span><span style="background-color:#272822;color:#f8f8f2;">: </span><span style="background-color:#272822;color:#f92672;">&amp;</span><span style="background-color:#272822;color:#f8f8f2;">Context| -&gt; Calculation {
</span><span style="background-color:#272822;color:#f8f8f2;">    </span><span style="background-color:#272822;color:#f92672;">if</span><span style="background-color:#272822;color:#f8f8f2;"> args.</span><span style="background-color:#272822;color:#66d9ef;">len</span><span style="background-color:#272822;color:#f8f8f2;">() </span><span style="background-color:#272822;color:#f92672;">!= </span><span style="background-color:#272822;color:#ae81ff;">2 </span><span style="background-color:#272822;color:#f8f8f2;">{ </span><span style="background-color:#272822;color:#f92672;">return </span><span style="background-color:#272822;font-style:italic;color:#66d9ef;">Err</span><span style="background-color:#272822;color:#f8f8f2;">(MathError::IncorrectArguments) }
</span><span style="background-color:#272822;color:#f8f8f2;">
</span><span style="background-color:#272822;color:#f8f8f2;">    </span><span style="background-color:#272822;font-style:italic;color:#66d9ef;">let</span><span style="background-color:#272822;color:#f8f8f2;"> a </span><span style="background-color:#272822;color:#f92672;">=</span><span style="background-color:#272822;color:#f8f8f2;"> args[</span><span style="background-color:#272822;color:#ae81ff;">0</span><span style="background-color:#272822;color:#f8f8f2;">].</span><span style="background-color:#272822;color:#66d9ef;">eval_ctx</span><span style="background-color:#272822;color:#f8f8f2;">(ctx)</span><span style="background-color:#272822;color:#f92672;">?</span><span style="background-color:#272822;color:#f8f8f2;">;
</span><span style="background-color:#272822;color:#f8f8f2;">    </span><span style="background-color:#272822;font-style:italic;color:#66d9ef;">let</span><span style="background-color:#272822;color:#f8f8f2;"> b </span><span style="background-color:#272822;color:#f92672;">=</span><span style="background-color:#272822;color:#f8f8f2;"> args[</span><span style="background-color:#272822;color:#ae81ff;">1</span><span style="background-color:#272822;color:#f8f8f2;">].</span><span style="background-color:#272822;color:#66d9ef;">eval_ctx</span><span style="background-color:#272822;color:#f8f8f2;">(ctx)</span><span style="background-color:#272822;color:#f92672;">?</span><span style="background-color:#272822;color:#f8f8f2;">;
</span><span style="background-color:#272822;color:#f8f8f2;">    </span><span style="background-color:#272822;font-style:italic;color:#66d9ef;">Ok</span><span style="background-color:#272822;color:#f8f8f2;">(a </span><span style="background-color:#272822;color:#f92672;">+</span><span style="background-color:#272822;color:#f8f8f2;"> b)
</span><span style="background-color:#272822;color:#f8f8f2;">});
</span><span style="background-color:#272822;color:#f8f8f2;">
</span><span style="background-color:#272822;font-style:italic;color:#66d9ef;">struct </span><span style="background-color:#272822;color:#f8f8f2;">FuncB;
</span><span style="background-color:#272822;font-style:italic;color:#66d9ef;">impl </span><span style="background-color:#272822;color:#f8f8f2;">Func </span><span style="background-color:#272822;color:#f92672;">for </span><span style="background-color:#272822;color:#f8f8f2;">FuncB {
</span><span style="background-color:#272822;color:#f8f8f2;">    </span><span style="background-color:#272822;font-style:italic;color:#66d9ef;">fn </span><span style="background-color:#272822;color:#a6e22e;">eval</span><span style="background-color:#272822;color:#f8f8f2;">(</span><span style="background-color:#272822;color:#f92672;">&amp;</span><span style="background-color:#272822;font-style:italic;color:#fd971f;">self</span><span style="background-color:#272822;color:#f8f8f2;">, </span><span style="background-color:#272822;font-style:italic;color:#fd971f;">args</span><span style="background-color:#272822;color:#f8f8f2;">: </span><span style="background-color:#272822;color:#f92672;">&amp;</span><span style="background-color:#272822;color:#f8f8f2;">[Term], </span><span style="background-color:#272822;font-style:italic;color:#fd971f;">ctx</span><span style="background-color:#272822;color:#f8f8f2;">: </span><span style="background-color:#272822;color:#f92672;">&amp;</span><span style="background-color:#272822;color:#f8f8f2;">Context) -&gt; Calculation {
</span><span style="background-color:#272822;color:#f8f8f2;">        </span><span style="background-color:#272822;color:#f92672;">if</span><span style="background-color:#272822;color:#f8f8f2;"> args.</span><span style="background-color:#272822;color:#66d9ef;">is_empty</span><span style="background-color:#272822;color:#f8f8f2;">() { </span><span style="background-color:#272822;color:#f92672;">return </span><span style="background-color:#272822;font-style:italic;color:#66d9ef;">Err</span><span style="background-color:#272822;color:#f8f8f2;">(MathError::IncorrectArguments) }
</span><span style="background-color:#272822;color:#f8f8f2;">
</span><span style="background-color:#272822;color:#f8f8f2;">        </span><span style="background-color:#272822;font-style:italic;color:#66d9ef;">let </span><span style="background-color:#272822;color:#f92672;">mut</span><span style="background-color:#272822;color:#f8f8f2;"> sum </span><span style="background-color:#272822;color:#f92672;">= </span><span style="background-color:#272822;color:#ae81ff;">0.0</span><span style="background-color:#272822;color:#f8f8f2;">;
</span><span style="background-color:#272822;color:#f8f8f2;">        </span><span style="background-color:#272822;color:#f92672;">for</span><span style="background-color:#272822;color:#f8f8f2;"> arg </span><span style="background-color:#272822;color:#f92672;">in</span><span style="background-color:#272822;color:#f8f8f2;"> args {
</span><span style="background-color:#272822;color:#f8f8f2;">            </span><span style="background-color:#272822;color:#f8f8f2;">sum </span><span style="background-color:#272822;color:#f92672;">+=</span><span style="background-color:#272822;color:#f8f8f2;"> arg.</span><span style="background-color:#272822;color:#66d9ef;">eval_ctx</span><span style="background-color:#272822;color:#f8f8f2;">(ctx)</span><span style="background-color:#272822;color:#f92672;">?</span><span style="background-color:#272822;color:#f8f8f2;">;
</span><span style="background-color:#272822;color:#f8f8f2;">        </span><span style="background-color:#272822;color:#f8f8f2;">}
</span><span style="background-color:#272822;color:#f8f8f2;">        </span><span style="background-color:#272822;font-style:italic;color:#66d9ef;">Ok</span><span style="background-color:#272822;color:#f8f8f2;">(sum)
</span><span style="background-color:#272822;color:#f8f8f2;">    </span><span style="background-color:#272822;color:#f8f8f2;">}
</span><span style="background-color:#272822;color:#f8f8f2;">}
</span><span style="background-color:#272822;color:#f8f8f2;">ctx.</span><span style="background-color:#272822;color:#66d9ef;">set_func</span><span style="background-color:#272822;color:#f8f8f2;">(</span><span style="background-color:#272822;color:#e6db74;">&quot;funcb&quot;</span><span style="background-color:#272822;color:#f8f8f2;">, FuncB);
</span><span style="background-color:#272822;color:#f8f8f2;">
</span><span style="background-color:#272822;font-style:italic;color:#66d9ef;">let </span><span style="background-color:#272822;color:#f92672;">mut</span><span style="background-color:#272822;color:#f8f8f2;"> expr </span><span style="background-color:#272822;color:#f92672;">= </span><span style="background-color:#272822;color:#f8f8f2;">Expression::parse_ctx(</span><span style="background-color:#272822;color:#e6db74;">&quot;funca(5, funcb(3, 4, 3))&quot;</span><span style="background-color:#272822;color:#f8f8f2;">, ctx)</span><span style="background-color:#272822;color:#f92672;">?</span><span style="background-color:#272822;color:#f8f8f2;">;
</span><span style="background-color:#272822;color:#f8f8f2;">expr.</span><span style="background-color:#272822;color:#66d9ef;">eval</span><span style="background-color:#272822;color:#f8f8f2;">()</span><span style="background-color:#272822;color:#f92672;">?</span><span style="background-color:#272822;color:#f8f8f2;">; </span><span style="background-color:#272822;color:#75715e;">// 15.0
</span><span style="background-color:#272822;color:#f8f8f2;">
</span><span style="background-color:#272822;color:#f8f8f2;">expr.ctx.</span><span style="background-color:#272822;color:#66d9ef;">set_func</span><span style="background-color:#272822;color:#f8f8f2;">(</span><span style="background-color:#272822;color:#e6db74;">&quot;funca&quot;</span><span style="background-color:#272822;color:#f8f8f2;">, |</span><span style="background-color:#272822;font-style:italic;color:#fd971f;">args</span><span style="background-color:#272822;color:#f8f8f2;">: </span><span style="background-color:#272822;color:#f92672;">&amp;</span><span style="background-color:#272822;color:#f8f8f2;">[Term], </span><span style="background-color:#272822;font-style:italic;color:#fd971f;">ctx</span><span style="background-color:#272822;color:#f8f8f2;">: </span><span style="background-color:#272822;color:#f92672;">&amp;</span><span style="background-color:#272822;color:#f8f8f2;">Context| -&gt; Calculation {
</span><span style="background-color:#272822;color:#f8f8f2;">    </span><span style="background-color:#272822;color:#f92672;">if</span><span style="background-color:#272822;color:#f8f8f2;"> args.</span><span style="background-color:#272822;color:#66d9ef;">len</span><span style="background-color:#272822;color:#f8f8f2;">() </span><span style="background-color:#272822;color:#f92672;">!= </span><span style="background-color:#272822;color:#ae81ff;">2 </span><span style="background-color:#272822;color:#f8f8f2;">{ </span><span style="background-color:#272822;color:#f92672;">return </span><span style="background-color:#272822;font-style:italic;color:#66d9ef;">Err</span><span style="background-color:#272822;color:#f8f8f2;">(MathError::IncorrectArguments) }
</span><span style="background-color:#272822;color:#f8f8f2;">
</span><span style="background-color:#272822;color:#f8f8f2;">    </span><span style="background-color:#272822;font-style:italic;color:#66d9ef;">let</span><span style="background-color:#272822;color:#f8f8f2;"> a </span><span style="background-color:#272822;color:#f92672;">=</span><span style="background-color:#272822;color:#f8f8f2;"> args[</span><span style="background-color:#272822;color:#ae81ff;">0</span><span style="background-color:#272822;color:#f8f8f2;">].</span><span style="background-color:#272822;color:#66d9ef;">eval_ctx</span><span style="background-color:#272822;color:#f8f8f2;">(ctx)</span><span style="background-color:#272822;color:#f92672;">?</span><span style="background-color:#272822;color:#f8f8f2;">;
</span><span style="background-color:#272822;color:#f8f8f2;">    </span><span style="background-color:#272822;font-style:italic;color:#66d9ef;">let</span><span style="background-color:#272822;color:#f8f8f2;"> b </span><span style="background-color:#272822;color:#f92672;">=</span><span style="background-color:#272822;color:#f8f8f2;"> args[</span><span style="background-color:#272822;color:#ae81ff;">1</span><span style="background-color:#272822;color:#f8f8f2;">].</span><span style="background-color:#272822;color:#66d9ef;">eval_ctx</span><span style="background-color:#272822;color:#f8f8f2;">(ctx)</span><span style="background-color:#272822;color:#f92672;">?</span><span style="background-color:#272822;color:#f8f8f2;">;
</span><span style="background-color:#272822;color:#f8f8f2;">    </span><span style="background-color:#272822;font-style:italic;color:#66d9ef;">Ok</span><span style="background-color:#272822;color:#f8f8f2;">(a </span><span style="background-color:#272822;color:#f92672;">-</span><span style="background-color:#272822;color:#f8f8f2;"> b)
</span><span style="background-color:#272822;color:#f8f8f2;">});
</span><span style="background-color:#272822;color:#f8f8f2;">
</span><span style="background-color:#272822;color:#f8f8f2;">expr.</span><span style="background-color:#272822;color:#66d9ef;">eval</span><span style="background-color:#272822;color:#f8f8f2;">()</span><span style="background-color:#272822;color:#f92672;">?</span><span style="background-color:#272822;color:#f8f8f2;">; </span><span style="background-color:#272822;color:#75715e;">// -5.0
</span></pre>
<p>As you might be able to tell from the example, there's more to an <code>Expression</code>. An expression is actually a combination of the <code>String</code> it was originally
parsed with, the <code>Context</code> it was parsed with (the default if it wasn't specified), and a <code>Term</code>. The <code>Term</code> is where the equation is actually stored. If you want a pure representation of an equation without anything extra, use a <code>Term</code>. The API is very similar to the one used by <code>Expression</code>.</p>
<p>And that's about the extent of this library's capabilities, for now at least. In the future I hope to improve it with lots of changes and new features, but this is the first instance of a fully working product.</p>
<h2 id="implementation">Implementation</h2>
<p>Parsing an equation with MEXPRP goes through multiple steps, as well as data structures. A common philosophy in languages like Rust when defining data structures is to make incorrect states impossible. In honor of this, MEXPRP has a different data structure for almost every step of parsing. The parsing steps are as so:</p>
<ol>
<li>Tokenize (convert the string input into a list of tokens)</li>
<li>Organize parentheses (from the list of tokens, replace parentheses with lists of the tokens within the parentheses).</li>
<li>Decide if names are variables or functions (using the context and the tokens following the names)</li>
<li>Split function arguments by commas (Happens at the same time as step 3)</li>
<li>Insert multiplication signs between operands that are right next to each other (implement implicit multiplication)</li>
<li>Convert the expression to postfix (Using shunting-yard, except without the parentheses as they were already parsed out in step 2)</li>
<li>Convert the postfix tokens to a single item representation that can either be an operand or an operation over more of the same type.</li>
</ol>
<p>Many of these steps have their own specific data structure. Step 1 creates a <code>Vec&lt;Token&gt;</code>, where a token is defined as</p>
<pre style="background-color:#272822">
<span style="background-color:#272822;font-style:italic;color:#66d9ef;">enum </span><span style="background-color:#272822;color:#f8f8f2;">Token {
</span><span style="background-color:#272822;color:#f8f8f2;">    </span><span style="background-color:#272822;color:#f8f8f2;">Paren(Paren),
</span><span style="background-color:#272822;color:#f8f8f2;">    </span><span style="background-color:#272822;color:#f8f8f2;">Op(Op),
</span><span style="background-color:#272822;color:#f8f8f2;">    </span><span style="background-color:#272822;color:#f8f8f2;">Name(</span><span style="background-color:#272822;font-style:italic;color:#66d9ef;">String</span><span style="background-color:#272822;color:#f8f8f2;">),
</span><span style="background-color:#272822;color:#f8f8f2;">    </span><span style="background-color:#272822;color:#f8f8f2;">Num(</span><span style="background-color:#272822;font-style:italic;color:#66d9ef;">f64</span><span style="background-color:#272822;color:#f8f8f2;">),
</span><span style="background-color:#272822;color:#f8f8f2;">    </span><span style="background-color:#272822;color:#f8f8f2;">Comma,
</span><span style="background-color:#272822;color:#f8f8f2;">}
</span></pre>
<p>Step two turns a <code>Vec&lt;Token&gt;</code> into a <code>Vec&lt;ParenToken&gt;</code>, which is defined as</p>
<pre style="background-color:#272822">
<span style="background-color:#272822;font-style:italic;color:#66d9ef;">enum </span><span style="background-color:#272822;color:#f8f8f2;">ParenToken {
</span><span style="background-color:#272822;color:#f8f8f2;">    </span><span style="background-color:#272822;color:#f8f8f2;">Op(Op),
</span><span style="background-color:#272822;color:#f8f8f2;">    </span><span style="background-color:#272822;color:#f8f8f2;">Name(</span><span style="background-color:#272822;font-style:italic;color:#66d9ef;">String</span><span style="background-color:#272822;color:#f8f8f2;">),
</span><span style="background-color:#272822;color:#f8f8f2;">    </span><span style="background-color:#272822;color:#f8f8f2;">Num(</span><span style="background-color:#272822;font-style:italic;color:#66d9ef;">f64</span><span style="background-color:#272822;color:#f8f8f2;">),
</span><span style="background-color:#272822;color:#f8f8f2;">    </span><span style="background-color:#272822;color:#f8f8f2;">Sub(Vec&lt;ParenToken&gt;),
</span><span style="background-color:#272822;color:#f8f8f2;">    </span><span style="background-color:#272822;color:#f8f8f2;">Comma,
</span><span style="background-color:#272822;color:#f8f8f2;">}
</span></pre>
<p>Step three and four turn that <code>Vec&lt;ParenToken&gt;</code> into a <code>Vec&lt;Expr&gt;</code> (which is kind of confusingly named and as such is a private type for now). These steps eliminate commas, and as such the next data structure cannot contains commas.</p>
<pre style="background-color:#272822">
<span style="background-color:#272822;font-style:italic;color:#66d9ef;">enum </span><span style="background-color:#272822;color:#f8f8f2;">Expr {
</span><span style="background-color:#272822;color:#f8f8f2;">    </span><span style="background-color:#272822;color:#f8f8f2;">Num(</span><span style="background-color:#272822;font-style:italic;color:#66d9ef;">f64</span><span style="background-color:#272822;color:#f8f8f2;">),
</span><span style="background-color:#272822;color:#f8f8f2;">    </span><span style="background-color:#272822;color:#f8f8f2;">Op(Op),
</span><span style="background-color:#272822;color:#f8f8f2;">    </span><span style="background-color:#272822;color:#f8f8f2;">Sub(Vec&lt;Expr&gt;),
</span><span style="background-color:#272822;color:#f8f8f2;">    </span><span style="background-color:#272822;color:#f8f8f2;">Var(</span><span style="background-color:#272822;font-style:italic;color:#66d9ef;">String</span><span style="background-color:#272822;color:#f8f8f2;">),
</span><span style="background-color:#272822;color:#f8f8f2;">    </span><span style="background-color:#272822;color:#f8f8f2;">Func(</span><span style="background-color:#272822;font-style:italic;color:#66d9ef;">String</span><span style="background-color:#272822;color:#f8f8f2;">, Vec&lt;Vec&lt;Expr&gt;&gt;),
</span><span style="background-color:#272822;color:#f8f8f2;">}
</span></pre>
<p>Step five and six use the same representation.</p>
<p>Step seven is where the tokens are converted to the final-ish representation, a <code>Term</code>, which is very easy to work with.</p>
<pre style="background-color:#272822">
<span style="background-color:#272822;color:#f92672;">pub </span><span style="background-color:#272822;font-style:italic;color:#66d9ef;">enum </span><span style="background-color:#272822;color:#f8f8f2;">Term {
</span><span style="background-color:#272822;color:#f8f8f2;">    </span><span style="background-color:#272822;color:#f8f8f2;">Num(</span><span style="background-color:#272822;font-style:italic;color:#66d9ef;">f64</span><span style="background-color:#272822;color:#f8f8f2;">),
</span><span style="background-color:#272822;color:#f8f8f2;">    </span><span style="background-color:#272822;color:#f8f8f2;">Operation(Box&lt;Operate&gt;),
</span><span style="background-color:#272822;color:#f8f8f2;">    </span><span style="background-color:#272822;color:#f8f8f2;">Function(</span><span style="background-color:#272822;font-style:italic;color:#66d9ef;">String</span><span style="background-color:#272822;color:#f8f8f2;">, Vec&lt;Term&gt;),
</span><span style="background-color:#272822;color:#f8f8f2;">    </span><span style="background-color:#272822;color:#f8f8f2;">Var(</span><span style="background-color:#272822;font-style:italic;color:#66d9ef;">String</span><span style="background-color:#272822;color:#f8f8f2;">),
</span><span style="background-color:#272822;color:#f8f8f2;">}
</span></pre>
	</div>
</body>

</html>